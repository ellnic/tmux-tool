#!/usr/bin/env bash
set -Eeuo pipefail

APP_NAME="TT - Tmux Tool"

WT_LAST_RC=0
WT_LAST_ERR=""
DEFAULT_LINK_NAME_PRIMARY="tt"
DEFAULT_LINK_NAME_FALLBACK="ttool"

SCRIPT_PATH="$(readlink -f "$0" 2>/dev/null || realpath "$0" 2>/dev/null || echo "$0")"

script_fingerprint() {
  local path="$SCRIPT_PATH"
  local lines sha
  lines="$(wc -l < "$path" 2>/dev/null || echo "?")"
  if have sha256sum; then
    sha="$(sha256sum "$path" 2>/dev/null | awk '{print $1}')"
  else
    sha="(sha256sum not found)"
  fi
  printf "Path: %s\nLines: %s\nSHA256: %s\n" "$path" "$lines" "${sha:-?}"
}

self_check_functions() {
  local missing=() fn
  local required=(
    wt pause_box yesno input_box password_box menu_box
    require_whiptail require_tmux tmux_safe
    list_sessions_lines pick_session pick_sessions_multi
    action_new_session action_attach_or_switch action_list_sessions action_info
    action_rename_session action_rename_session_for action_kill_session action_kill_session_for action_kill_server
    install_shortcut inside_tt_menu main_menu
  )

  for fn in "${required[@]}"; do
    declare -F "$fn" >/dev/null 2>&1 || missing+=("$fn")
  done

  if (( ${#missing[@]} > 0 )); then
    local fp ttpath
    fp="$(script_fingerprint)"
    ttpath="$(command -v tt 2>/dev/null || echo tt)"
    pause_box "Internal error: missing functions:\n\n  ${missing[*]}\n\nThis almost always means you're NOT running the file you think you are.\n\n${fp}\n\nTip:\n  type -a tt\n  readlink -f ${ttpath}"
    exit 1
  fi
}

die() { echo "ERROR: $*" >&2; exit 1; }

have() { command -v "$1" >/dev/null 2>&1; }

# --- errexit helpers ---------------------------------------------------------
# Under `set -e`, any non-zero return inside a command substitution can kill the script.
# For interactive/UI flows we intentionally allow non-zero and handle it explicitly.
ERREXIT_STACK=()

errexit_push_off() {
  local was=0
  [[ $- == *e* ]] && was=1 && set +e
  ERREXIT_STACK+=("$was")
}

errexit_pop() {
  local n="${#ERREXIT_STACK[@]}"
  (( n > 0 )) || return 0
  local was="${ERREXIT_STACK[n-1]}"
  unset 'ERREXIT_STACK[n-1]'
  [[ "$was" == "1" ]] && set -e
}
# -----------------------------------------------------------------------------


must_have_fn() {
  local fn="$1"
  if ! declare -F "$fn" >/dev/null 2>&1; then
    local fp
    fp="$(script_fingerprint)"
    pause_box "Internal error: function missing at runtime: ${fn}\n\n${fp}"
    return 1
  fi
  return 0
}


wt() {
  # Run whiptail safely under set -e, capture the selection, and keep stderr for diagnostics.
  # IMPORTANT: use --output-fd so we do NOT break menu selections (whiptail normally writes them to stderr).
  local rc out tmp
  tmp="$(mktemp -t tt-whiptail-err.XXXXXX 2>/dev/null || mktemp)"
  WT_LAST_ERR=""
  WT_LAST_RC=0

  errexit_push_off
  out="$(whiptail --output-fd 3 "$@" 3>&1 1>/dev/tty 2>"$tmp")"
  rc=$?
  WT_LAST_RC=$rc
  WT_LAST_ERR="$(<"$tmp")"
  rm -f "$tmp"
  errexit_pop

  printf '%s' "$out"
  return $rc
}

term_cols() { tput cols 2>/dev/null || echo 80; }

term_notice() {
  # Fallback when whiptail cannot render (eg, "Screen too small").
  # Keep it simple and obvious in the terminal.
  local msg="$1"
  echo
  echo "[$APP_NAME] $msg" >&2
  [[ -n "${WT_LAST_ERR:-}" ]] && echo "Details: ${WT_LAST_ERR}" >&2
  echo "Press Enter to continue..." >&2
  read -r _
}
term_lines() { tput lines 2>/dev/null || echo 24; }

clamp() {
  local v="$1" lo="$2" hi="$3"

  # If the terminal is smaller than our desired minimum, clamp to what is actually possible.
  (( hi < 1 )) && hi=1
  (( lo < 1 )) && lo=1
  (( hi < lo )) && lo="$hi"

  (( v < lo )) && v="$lo"
  (( v > hi )) && v="$hi"
  echo "$v"
}

# Calculate a reasonable width for whiptail boxes based on message content.
# Keeps things compact for short text but never exceeds the terminal width.
calc_box_width() {
  local text="$1"
  local pad="${2:-8}"
  local max=0 line len
  while IFS= read -r line; do
    len="${#line}"
    (( len > max )) && max="$len"
  done <<< "${text}"
  local cols; cols="$(term_cols)"
  clamp "$(( max + pad ))" 40 "$(( cols > 8 ? cols - 4 : cols ))"
}

# Height based on line count, with a little padding.
calc_box_height() {
  local text="$1"
  local pad="${2:-6}"
  local n=0
  while IFS= read -r _; do ((n++)); done <<< "${text}"
  local rows; rows="$(term_lines)"
  clamp "$(( n + pad ))" 10 "$(( rows > 8 ? rows - 4 : rows ))"
}

wt_textbox() {
  # Usage: wt_textbox "<title>" "<content>" [height_pad] [width_pad]
  # Avoids process-substitution (/dev/fd/*) which can cause whiptail to drop to the terminal.
  local title="$1"
  local content="$2"
  local hpad="${3:-6}"
  local wpad="${4:-8}"
  local h w tmp
  h="$(calc_box_height "$content" "$hpad")"
  w="$(calc_box_width "$content" "$wpad")"
  tmp="$(mktemp -t tt-textbox.XXXXXX)"
  printf "%s\n" "$content" >"$tmp"
  if ! wt --title "$title" --scrolltext --textbox "$tmp" "$h" "$w"; then
    local rc="$WT_LAST_RC"
    # Esc is 255, treat as normal cancel.
    if [[ "$rc" != "255" && -n "${WT_LAST_ERR:-}" ]]; then
      term_notice "Dialog failed to open (rc=$rc, size=${h}x${w}, term=$(term_lines)x$(term_cols)). Try enlarging the terminal or tmux pane."
    fi
  fi
  rm -f "$tmp"
}

show_session_info() {
  local s="$1"
  local out rc

  # This uses a command-substitution that runs multiple tmux queries.
  # Under `set -euo pipefail`, any failure inside would normally hard-exit.
  # Guard it so missing/vanished sessions just show a friendly message.
  errexit_push_off
  out="$(
    echo "============================================================"
    echo "Session: $s"
    echo "============================================================"
    echo

    if tmux has-session -t "$s" 2>/dev/null; then
      tmux list-windows -t "$s" -F '  [#I] #W  (panes:#P)  active:#{?window_active,yes,no}' 2>/dev/null || true
      echo
      echo "Panes in active window:"
      tmux list-panes -t "$s" -F '  pane:#P  pid:#{pane_pid}  cmd:#{pane_current_command}  path:#{pane_current_path}' 2>/dev/null || true
    else
      echo "  (Session '$s' no longer exists.)"
    fi

    echo
  )"
  rc=$?
  errexit_pop

  if [[ "$rc" != "0" ]]; then
    out="Failed to query tmux for session '$s'.\n\nTry again, or check tmux is running."
  fi

  wt_textbox "$APP_NAME" "$out" 6 8
}


pause_box() {
  # shellcheck disable=SC2068
  local msg="$*"
  local h w
  h="$(calc_box_height "$msg")"
  w="$(calc_box_width "$msg")"
  if ! wt --title "$APP_NAME" --msgbox "$msg" "$h" "$w"; then
    local rc="$WT_LAST_RC"
    if [[ "$rc" != "255" && -n "${WT_LAST_ERR:-}" ]]; then
      term_notice "Dialog failed to open (rc=$rc, size=${h}x${w}, term=$(term_lines)x$(term_cols)). Try enlarging the terminal or tmux pane."
    fi
  fi
}

yesno() {
  # Returns 0 for yes, 1 for no
  # Default to NO by using --defaultno
  local msg="$1"
  local h w
  h="$(calc_box_height "$msg")"
  w="$(calc_box_width "$msg")"
  if ! wt --title "$APP_NAME" --defaultno --yesno "$msg" "$h" "$w"; then
    local rc="$WT_LAST_RC"
    if [[ "$rc" != "255" && -n "${WT_LAST_ERR:-}" ]]; then
      term_notice "Dialog failed to open (rc=$rc, size=${h}x${w}, term=$(term_lines)x$(term_cols)). Try enlarging the terminal or tmux pane."
    fi
    return 1
  fi
}

input_box() {
  local prompt="$1"
  local default="${2-}"
  local out rc tmp
  local h w
  h="$(calc_box_height "$prompt")"
  w="$(calc_box_width "$prompt")"

  tmp="$(mktemp -t tt-wt-out.XXXXXX 2>/dev/null || mktemp)"
  errexit_push_off
  wt --title "$APP_NAME" --inputbox "$prompt" "$h" "$w" "$default" >"$tmp"
  rc=$?
  out="$(<"$tmp")"
  rm -f "$tmp"
  errexit_pop

  if [[ "$rc" != "0" ]]; then
    if [[ "$rc" != "255" && -n "${WT_LAST_ERR:-}" ]]; then
      term_notice "Dialog failed to open (rc=$rc, size=${h}x${w}, term=$(term_lines)x$(term_cols)). Try enlarging the terminal or tmux pane."
    fi
    return "$rc"
  fi

  printf "%s" "$out"
  return 0
}

password_box() {
  local prompt="$1"
  local out rc tmp
  local h w
  h="$(calc_box_height "$prompt")"
  w="$(calc_box_width "$prompt")"

  tmp="$(mktemp -t tt-wt-out.XXXXXX 2>/dev/null || mktemp)"
  errexit_push_off
  wt --title "$APP_NAME" --passwordbox "$prompt" "$h" "$w" >"$tmp"
  rc=$?
  out="$(<"$tmp")"
  rm -f "$tmp"
  errexit_pop

  if [[ "$rc" != "0" ]]; then
    if [[ "$rc" != "255" && -n "${WT_LAST_ERR:-}" ]]; then
      term_notice "Dialog failed to open (rc=$rc, size=${h}x${w}, term=$(term_lines)x$(term_cols)). Try enlarging the terminal or tmux pane."
    fi
    return 1
  fi

  printf "%s" "$out"
}

menu_box() {
  local title="$1"
  shift

  local default_item="${TT_MENU_DEFAULT_ITEM:-}"
  # If the caller didn't specify, highlight the first tag by default.
  [[ -n "$default_item" ]] || default_item="${1:-}"

  # Keep original args intact for whiptail, but also inspect them for sizing.
  local -a menu_args
  menu_args=( "$@" )

  # Estimate a compact but readable menu size from item text.
  local rows cols items max=0 i tag desc line
  rows="$(term_lines)"
  cols="$(term_cols)"

  items="${#menu_args[@]}"
  for ((i=0; i<items; i+=2)); do
    tag="${menu_args[i]}"
    desc="${menu_args[i+1]:-}"
    line="${tag} ${desc}"
    ((${#line} > max)) && max="${#line}"
  done

  local height width listheight
  listheight="$(( items / 2 ))"
  height="$(clamp "$(( listheight + 9 ))" 14 "$(( rows > 10 ? rows - 4 : rows ))")"
  width="$(clamp "$(( max + 14 ))" 60 "$(( cols > 10 ? cols - 4 : cols ))")"

  wt \
    --title "$APP_NAME" \
    --ok-button "Select" \
    --cancel-button "Exit" \
    --default-item "$default_item" \
    --menu "$title" "$height" "$width" "$(( listheight > 12 ? 12 : listheight ))" \
    "${menu_args[@]}" \
    || return 1
}

detect_os_install_hint() {
  local os_id=""
  local os_like=""
  if [[ -r /etc/os-release ]]; then
    # shellcheck disable=SC1091
    source /etc/os-release
    os_id="${ID:-}"
    os_like="${ID_LIKE:-}"
  fi

  if have apt-get || [[ "$os_id" == "debian" || "$os_id" == "ubuntu" || "$os_like" == *"debian"* ]]; then
    echo "Try: sudo apt-get update && sudo apt-get install -y tmux whiptail"
  elif have dnf || [[ "$os_id" == "fedora" || "$os_like" == *"fedora"* || "$os_like" == *"rhel"* ]]; then
    echo "Try: sudo dnf install -y tmux newt"
  elif have yum || [[ "$os_like" == *"rhel"* || "$os_like" == *"centos"* ]]; then
    echo "Try: sudo yum install -y tmux newt"
  elif have pacman || [[ "$os_id" == "arch" || "$os_like" == *"arch"* ]]; then
    echo "Try: sudo pacman -S --needed tmux libnewt"
  elif have zypper || [[ "$os_id" == "opensuse" || "$os_like" == *"suse"* ]]; then
    echo "Try: sudo zypper install -y tmux whiptail"
  elif have apk || [[ "$os_id" == "alpine" ]]; then
    echo "Try: sudo apk add tmux newt"
  else
    echo "Install tmux + whiptail using your distro's package manager (packages often named: tmux, whiptail or newt)."
  fi
}

require_whiptail() {
  have whiptail || die "whiptail is required. Install it, then re-run. $(detect_os_install_hint)"
}

require_tmux() {
  if ! have tmux; then
    require_whiptail
    pause_box "tmux isn't installed.\n\n$(detect_os_install_hint)\n\nExiting."
    exit 1
  fi
}

tmux_safe() {
  if ! tmux "$@"; then
    pause_box "tmux command failed:\n\ntmux $*\n\n(See terminal output if any.)"
    return 1
  fi
}

# When TT runs *inside* a tmux client, killing sessions/server can drop the client mid-command.
# That can make tmux return non-zero even though the kill succeeded. Avoid scary errors by
# detaching this client and running the kill from the server.

tmux_detach_supports_E() {
  tmux detach-client -h 2>&1 | grep -q -- ' -E '
}

tmux_detach_then_exec() {
  # Arg: command string, e.g. "tmux kill-server" or "tmux kill-session -t 'name'"
  local cmd="$1"

  if tmux_detach_supports_E; then
    tmux detach-client -E "$cmd" 2>/dev/null || true
  else
    tmux run-shell -b "$cmd" 2>/dev/null || true
    tmux detach-client 2>/dev/null || true
  fi

  exit 0
}


current_tmux_session() {
  if [[ -n "${TMUX-}" ]] && tmux display-message -p '#S' >/dev/null 2>&1; then
    tmux display-message -p '#S'
  else
    return 1
  fi
}

tmux_client_last_session() {
  # Returns the last session for this client (best-effort). Empty/failed if unavailable.
  if [[ -n "${TMUX-}" ]] && tmux display-message -p '#{client_last_session}' >/dev/null 2>&1; then
    tmux display-message -p '#{client_last_session}' 2>/dev/null || return 1
  else
    return 1
  fi
}

resolve_kill_switch_dest() {
  # Decide where to switch this client *before* killing the currently-attached session.
  # Order:
  #  1) client_last_session (if it exists and is not the target)
  #  2) first non-target session from list-sessions
  #  3) empty -> caller should create a holding session
  local target="$1"
  local last="" dest=""

  last="$(tmux_client_last_session || true)"
  if [[ -n "$last" && "$last" != "$target" ]] && tmux has-session -t "$last" 2>/dev/null; then
    printf "%s" "$last"
    return 0
  fi

  dest="$(tmux list-sessions -F '#S' 2>/dev/null | grep -vxF "$target" | head -n1 || true)"
  [[ -n "$dest" ]] && { printf "%s" "$dest"; return 0; }

  return 1
}

cleanup_hold_session_if_safe() {
  # Conservative: only remove if:
  #  - session exists
  #  - no attached clients
  #  - single window AND panes appear idle shells
  local hold="$1"
  [[ -n "$hold" ]] || return 0
  tmux has-session -t "$hold" 2>/dev/null || return 0

  local attached windows
  attached="$(tmux display-message -p -t "$hold" '#{session_attached}' 2>/dev/null || echo "1")"
  windows="$(tmux display-message -p -t "$hold" '#{session_windows}' 2>/dev/null || echo "99")"

  [[ "$attached" == "0" ]] || return 0
  [[ "$windows" == "0" || "$windows" == "1" ]] || return 0

  # If any pane is running something other than an interactive shell, leave it.
  local cmds
  cmds="$(tmux list-panes -t "$hold" -F '#{pane_current_command}' 2>/dev/null || true)"
  [[ -n "$cmds" ]] || return 0

  while IFS= read -r c; do
    case "$c" in
      bash|sh|zsh|fish|dash) : ;;
      *) return 0 ;;
    esac
  done <<< "$cmds"

  tmux_safe kill-session -t "$hold"
}


list_sessions_lines() {
  tmux list-sessions -F '#S|#{session_windows}|#{session_attached}|#{session_created_string}' 2>/dev/null || true
}

pick_session() {
  local lines menu=() name win att created choice current=""
  lines="$(list_sessions_lines)"
  [[ -n "$lines" ]] || { pause_box "No current sessions detected."; return 1; }

  current="$(current_tmux_session || true)"

  while IFS='|' read -r name win att created; do
    if [[ -n "$current" && "$name" == "$current" ]]; then
      menu+=("$name" "windows:${win} attached:${att} created:${created}   (current)")
    else
      menu+=("$name" "windows:${win} attached:${att} created:${created}")
    fi
  done <<< "$lines"

  choice="$(menu_box "Select a session:" "${menu[@]}")" || return 1
  printf "%s" "$choice"
}


pick_sessions_multi() {
  # Returns one or more session names, one per line.
  local lines menu=() name win att created choice current=""
  lines="$(list_sessions_lines)"
  [[ -n "$lines" ]] || { pause_box "No current sessions detected."; return 1; }

  current="$(current_tmux_session || true)"

  # Build a checklist: tag, item, status
  while IFS='|' read -r name win att created; do
    local desc status
    desc="windows:${win} attached:${att} created:${created}"
    [[ -n "$current" && "$name" == "$current" ]] && desc="${desc}   (current)"
    status="OFF"
    menu+=("$name" "$desc" "$status")
  done <<< "$lines"

  errexit_push_off
  choice="$(wt --title "$APP_NAME" --separate-output --checklist "Select sessions:" 20 90 12 "${menu[@]}")"
  local rc=$?
  errexit_pop
  (( rc == 0 )) || return 1
  printf "%s\n" "$choice"
}


action_new_session() {
  # Always keep a consistent post-create flow:
  # 1) Attach now (default highlight)
  # 2) Create another
  # 3) Back to main menu
  while true; do
    local name choice rc
    errexit_push_off
    name="$(input_box "New session name:" "")"
    rc=$?
    errexit_pop
    if [[ "$rc" == "255" ]]; then
      return 0
    fi
    if [[ "$rc" != "0" ]]; then
      return 0
    fi
    [[ -n "$name" ]] || { pause_box "Name can't be empty."; continue; }

    if tmux has-session -t "$name" 2>/dev/null; then
      pause_box "Session '$name' already exists."
      continue
    fi

    # Create detached so we can offer the same post-create choice whether we're inside tmux or not.
    tmux_safe new-session -d -s "$name"

    TT_MENU_DEFAULT_ITEM="1"
    choice="$(
      menu_box "Created '$name'. What next?" \
        "1" "Attach now" \
        "2" "Create another" \
        "3" "Back to main menu"
    )" || { unset TT_MENU_DEFAULT_ITEM; return 0; }
    unset TT_MENU_DEFAULT_ITEM

    case "$choice" in
      1)
        if [[ -n "${TMUX-}" ]]; then
          tmux_safe switch-client -t "$name"
          return 0
        fi
        tmux_safe attach-session -t "$name"
        return 0
        ;;
      2) continue ;;
      3) return 0 ;;
    esac
  done
}



action_attach_or_switch() {
  local name current=""
  name="$(pick_session)" || return 0

  if [[ -n "${TMUX-}" ]]; then
    current="$(current_tmux_session || true)"
    if [[ -n "$current" && "$name" == "$current" ]]; then
      pause_box "You're already in session '$current'."
      return 0
    fi
    tmux_safe switch-client -t "$name"
  else
    tmux_safe attach-session -t "$name"
  fi
}


action_kill_session() {
  local s
  s="$(pick_session)" || return 0
  if yesno "Really kill session '$s'?\n\nThis will terminate all processes in it."; then
    if [[ -n "${TMUX-}" ]]; then
      # Running inside a tmux client: detach this client and run the kill from the server to avoid
      # a scary non-zero return when the client connection drops mid-command.
      local s_q
      printf -v s_q '%q' "$s"
      tmux_detach_then_exec "tmux kill-session -t -- $s_q >/dev/null 2>&1 || true"
    fi
    # If we're currently *in* the session we're about to kill, move this client first.
    # Otherwise TT (running inside the session) can die mid-flow, or the user can appear to "still be in it".
    local current="" dest="" hold=""
    current="$(current_tmux_session || true)"
    if [[ -n "$current" && "$current" == "$s" ]]; then
      pause_box "You're killing the session you're currently attached to.\n\nTT will temporarily switch you to another session to keep itself alive.\n\nIf no other sessions exist, TT will create a temporary holding session named like:\n  __tt_hold_<pid>_<epoch>\n\nPress OK to continue."
      dest="$(resolve_kill_switch_dest "$s" || true)"
      if [[ -n "$dest" ]]; then
        tmux_safe switch-client -t "$dest"
      else
        hold="__tt_hold_${$}_$(date +%s)"
        tmux_safe new-session -d -s "$hold"
        tmux_safe switch-client -t "$hold"
      fi
    fi

    tmux_safe kill-session -t "$s"
    [[ -n "$hold" ]] && cleanup_hold_session_if_safe "$hold"
    pause_box "Killed '$s'."
  fi
}

action_kill_session_for() {
  local s="${1:-}"
  [[ -n "$s" ]] || return 0

  if ! tmux has-session -t "$s" 2>/dev/null; then
    pause_box "Session '$s' no longer exists."
    return 0
  fi

  if yesno "Really kill session '$s'?\n\nThis will terminate all processes in it."; then
    if [[ -n "${TMUX-}" ]]; then
      # Running inside a tmux client: detach this client and run the kill from the server to avoid
      # a scary non-zero return when the client connection drops mid-command.
      local s_q
      printf -v s_q '%q' "$s"
      tmux_detach_then_exec "tmux kill-session -t -- $s_q >/dev/null 2>&1 || true"
    fi
    # If we're currently *in* the session we're about to kill, move this client first.
    # Otherwise TT (running inside the session) can die mid-flow, or the user can appear to "still be in it".
    local current="" dest="" hold=""
    current="$(current_tmux_session || true)"
    if [[ -n "$current" && "$current" == "$s" ]]; then
      pause_box "You're killing the session you're currently attached to.\n\nTT will temporarily switch you to another session to keep itself alive.\n\nIf no other sessions exist, TT will create a temporary holding session named like:\n  __tt_hold_<pid>_<epoch>\n\nPress OK to continue."
      dest="$(resolve_kill_switch_dest "$s" || true)"
      if [[ -n "$dest" ]]; then
        tmux_safe switch-client -t "$dest"
      else
        hold="__tt_hold_${$}_$(date +%s)"
        tmux_safe new-session -d -s "$hold"
        tmux_safe switch-client -t "$hold"
      fi
    fi

    tmux_safe kill-session -t "$s"
    [[ -n "$hold" ]] && cleanup_hold_session_if_safe "$hold"
    pause_box "Killed '$s'."
  fi
}

action_rename_session_for() {
  local s="${1:-}" new
  [[ -n "$s" ]] || return 0

  if ! tmux has-session -t "$s" 2>/dev/null; then
    pause_box "Session '$s' no longer exists."
    return 0
  fi

  while true; do
    new="$(input_box "Rename session '$s' to:" "$s")" || return 0
    [[ -n "$new" ]] || { pause_box "New name can't be empty."; continue; }

    if [[ "$new" == "$s" ]]; then
      pause_box "Name unchanged."
      return 0
    fi

    if tmux has-session -t "$new" 2>/dev/null; then
      pause_box "A session named '$new' already exists.\n\nPick a different name."
      continue
    fi

    tmux_safe rename-session -t "$s" "$new"
    pause_box "Renamed '$s' -> '$new'."
    return 0
  done
}


action_rename_session() {
  local current="" s="" new action inside=0

  current="$(current_tmux_session || true)"
  [[ -n "$current" ]] && inside=1

  if (( inside )); then
    action="$(menu_box "Rename session" \
      "1" "Rename current session ('$current')" \
      "2" "Pick a different session" \
      "3" "Back")" || return 0
    case "$action" in
      1) s="$current" ;;
      2) s="$(pick_session)" || return 0 ;;
      3) return 0 ;;
    esac
  else
    s="$(pick_session)" || return 0
  fi

  new="$(input_box "Rename session '$s' to:" "$s")" || return 0
  [[ -n "$new" ]] || { pause_box "New name can't be empty."; return 0; }
  tmux_safe rename-session -t "$s" "$new"
  pause_box "Renamed '$s' -> '$new'."
}


action_info() {
  local s
  s="$(pick_session)" || return 0
  show_session_info "$s"
}


action_list_sessions() {
  local lines menu=() name win att created s action current="" inside=0

  lines="$(list_sessions_lines)"
  [[ -n "$lines" ]] || { pause_box "No current sessions detected.
"; return 0; }

  current="$(current_tmux_session || true)"
  [[ -n "$current" ]] && inside=1

  while IFS='|' read -r name win att created; do
    if [[ -n "$current" && "$name" == "$current" ]]; then
      menu+=("$name" "windows:${win} attached:${att} created:${created}   (current)")
    else
      menu+=("$name" "windows:${win} attached:${att} created:${created}")
    fi
  done <<< "$lines"

  s="$(menu_box "Current sessions:" "${menu[@]}")" || return 0

  while true; do
    if (( inside )); then
      action="$(menu_box "Session: $s" \
        "1" "Switch to this session" \
        "2" "Show session info" \
        "3" "Rename session" \
        "4" "Kill session" \
        "5" "Back")" || return 0
      case "$action" in
        1)
          if [[ -n "$current" && "$s" == "$current" ]]; then
            pause_box "You're already in session '$current'.

Switching to it would do nothing."
            return 0
          fi
          tmux_safe switch-client -t "$s"
          return 0
          ;;
        2) show_session_info "$s" ;;
        3) action_rename_session_for "$s" ;;
        4) action_kill_session_for "$s" ;;
        5) return 0 ;;
      esac
    else
      action="$(menu_box "Session: $s" \
        "1" "Attach to this session" \
        "2" "Show session info" \
        "3" "Rename session" \
        "4" "Kill session" \
        "5" "Back")" || return 0
      case "$action" in
        1) tmux_safe attach-session -t "$s"; return 0 ;;
        2) show_session_info "$s" ;;
        3) action_rename_session_for "$s" ;;
        4) action_kill_session_for "$s" ;;
        5) return 0 ;;
      esac
    fi
  done
}



action_kill_server() {
  if yesno "Kill the entire tmux server?\n\nThis kills ALL sessions."; then
    if [[ -n "${TMUX-}" ]]; then
      tmux_detach_then_exec "tmux kill-server >/dev/null 2>&1 || true"
    fi

    tmux_safe kill-server
    pause_box "tmux server killed."

    # Once the server is killed, this client context is no longer valid.
    # Exit immediately to avoid falling back into the menu and running more tmux commands.
    exit 0
  fi
}

suggest_link_name() {
  if have "$DEFAULT_LINK_NAME_PRIMARY"; then
    echo "$DEFAULT_LINK_NAME_FALLBACK"
  else
    echo "$DEFAULT_LINK_NAME_PRIMARY"
  fi
}

install_shortcut() {
  local target linkname bindir="/usr/local/bin" linkpath
  target="$SCRIPT_PATH"
  linkname="$(suggest_link_name)"
  linkpath="${bindir}/${linkname}"

  if have "$DEFAULT_LINK_NAME_PRIMARY"; then
    if [[ -L "${bindir}/${DEFAULT_LINK_NAME_PRIMARY}" ]]; then
      local resolved
      resolved="$(readlink -f "${bindir}/${DEFAULT_LINK_NAME_PRIMARY}" 2>/dev/null || true)"
      if [[ "$resolved" == "$target" ]]; then
        pause_box "Shortcut '${DEFAULT_LINK_NAME_PRIMARY}' already points to this script.\n\nAll good."
        return 0
      fi
    fi
  fi

  if have "$linkname"; then
    pause_box "Can't install shortcut '${linkname}' because a command already exists:\n\n$(command -v "$linkname")\n\nPick a different name."
    return 0
  fi

  # Safety: never overwrite a real file in /usr/local/bin.
  if [[ -e "$linkpath" && ! -L "$linkpath" ]]; then
    pause_box "Refusing to overwrite an existing non-symlink:\n\n${linkpath}\n\nRemove or rename it manually, then try again."
    return 0
  fi

  if ! yesno "Install a shortcut in ${bindir}?\n\nThis will create:\n  ${linkpath}  ->  ${target}\n\nName chosen: '${linkname}'"; then
    return 0
  fi

  local cmd=(ln -sf "$target" "$linkpath")
  if [[ "${EUID:-$(id -u)}" -eq 0 ]]; then
    "${cmd[@]}"
  else
    if have sudo; then
      # Avoid dropping to the terminal for a password prompt.
      if sudo -n true >/dev/null 2>&1; then
        sudo "${cmd[@]}" || { pause_box "sudo failed. Shortcut not installed."; return 0; }
      else
        local pw
        pw="$(password_box "sudo password required to install shortcut:")" || return 0
        if ! printf "%s\n" "$pw" | sudo -S -v >/dev/null 2>&1; then
          pw=""
          pause_box "sudo auth failed. Shortcut not installed."
          return 0
        fi
        pw=""
        sudo "${cmd[@]}" || { pause_box "sudo failed. Shortcut not installed."; return 0; }
      fi
    else
      pause_box "sudo not available. Run this manually as root:\n\nln -sf \"$target\" \"$linkpath\""
      return 0
    fi
  fi

  pause_box "Installed shortcut:\n\n${linkname}\n\nRun it from anywhere with:\n  ${linkname}"
}

inside_tt_menu() {
  # You're already inside tmux. Offer sensible actions instead of a warning box.
  local choice
  TT_MENU_DEFAULT_ITEM="1"
  choice="$(
    menu_box "You're inside a TT/tmux environment. What do you want to do?" \
      "1" "Main menu (manage sessions)" \
      "2" "Switch to another session now" \
      "3" "Exit tmux (detach this client)" \
      "4" "Exit"
  )" || return 1

  unset TT_MENU_DEFAULT_ITEM

  case "$choice" in
    1) return 0 ;;
    2) must_have_fn action_attach_or_switch && action_attach_or_switch; return 0 ;;
    3)
      tmux_safe detach-client
      exit 0
      ;;
    4) exit 0 ;;
  esac
}

main_menu() {
  while true; do
    local choice
    TT_MENU_DEFAULT_ITEM="1"
    choice="$(
      menu_box "Choose an action:" \
        "1" "Create new session" \
        "2" "Attach / switch to session" \
        "3" "List sessions" \
        "4" "Session info (windows/panes)" \
        "5" "Rename session" \
        "6" "Kill session" \
        "7" "Kill tmux server (ALL sessions)" \
        "8" "Install shortcut into /usr/local/bin" \
        "9" "Exit"
    )" || { unset TT_MENU_DEFAULT_ITEM; exit 0; }

    unset TT_MENU_DEFAULT_ITEM

    case "$choice" in
      1) must_have_fn action_new_session && action_new_session ;;
      2) must_have_fn action_attach_or_switch && action_attach_or_switch ;;
      3) must_have_fn action_list_sessions && action_list_sessions ;;
      4) must_have_fn action_info && action_info ;;
      5) must_have_fn action_rename_session && action_rename_session ;;
      6) must_have_fn action_kill_session && action_kill_session ;;
      7) must_have_fn action_kill_server && action_kill_server ;;
      8) must_have_fn install_shortcut && install_shortcut ;;
      9) exit 0 ;;
    esac
  done
}

main() {
  # Helpful for quickly proving which copy you're running.
  if [[ "${1:-}" == "--version" ]]; then
    echo "$APP_NAME"
    script_fingerprint
    echo "Bash: ${BASH_VERSION:-unknown}"
    exit 0
  fi

  require_whiptail
  require_tmux

  # Catch 'command not found' style issues early, with a clear fingerprint.
  self_check_functions

  if current_tmux_session >/dev/null 2>&1; then
    inside_tt_menu || exit 0
  fi

  main_menu
}

main "$@"
